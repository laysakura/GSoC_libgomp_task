具体的な実装をどうやるか、についてのメモ

Level1.基本的なユーザーレベルスレッドライブラリ
実装する必要のある機能:create,join,detach,yield

データ構造
runnable queue:実行可能なスレッドのキュー
not runnable queue:実行可能でないスレッドのキュー

create:スレッド作成
スレッドのディスクリプタを作成し、スケジューラに渡す
@スケジューラ:
1.not runnableもしくはrunnable queueのいずれかにディスクリプタを追加
2.必要ならばコンテキストスイッチも行う

join:スレッド終了待ち
1.指定されたスレッドの終了状態を確認
2.終了済みならば戻り値を返す
3.そうでなければ自身をnot runnableにし、そのスレッドの予約リストに
自身を入れておき、他のスレッドにコンテキストスイッチ

detach:スレッドの終了待ちを放棄
スレッドの状態をdetachedに変更

yield:スケジューラを呼び:スレッドの実行順を譲る
@スケジューラ
1.not runnableの中で実行可能なものをrunnableに移動
自スレッドをnot runnableに移動
2.runnableの中で最も優先度の高いものにコンテキストスイッチ

スレッド終了時:
detachされているのならば、ディスクリプタを解放
そうでないのならば、予約リストを参照。それに入っているスレッドをrunnableにする

Level2.マルチプロセッサに対応したユーザーレベルスレッドライブラリ
拡張:スケジューラの分散化
スケジューラをメインスレッドのみがもつのは簡単だがスケーラブルではない。
そこでスケジューラ(+ランキュー)は各ワーカースレッドに独立に持たせ、
スレッドを送り合うことで負荷の分散を図る。

デバッグメモ:exitとjoinの同時実行
exit:
A1.終了済みにする
A2.キューを実行可能にする

join:
B1.終了済みなら終わり
B2.キューに入れて制御を返す

起こりうるケース
A1->B1->A2:OK
B1->A1->B2->A2:OK(すぐに実行可能になる)
B1->A1->A2->B2:NG(joinが永遠に実行可能にならない)

改善案

結局、A1->A2とB1->B2はシリアライズしないといけないので、ロックを取って解決する。

アイデア:メモリ領域の軽量化
あるスレッドがcreateされてから、実際に作られるのをjoinされるまで遅延させられれば
join元のメモリ領域を共有できるよね?
アイデア:yieldの軽量化
スレッド数が1なら、yieldでスケジューラに戻る必要はない?

ファイル名のconvention

xxxx.h : 構造体と、インライン化の必要があり、しかも他のファイルに依存しない関数
xxxx.c : publicに公開したい関数
xxxx_func.h : インライン化の必要があり、しかも他のファイルに依存する関数
xxxx_proto.h : func.hに記述されている関数のプロトタイプ

・他のファイルの構造体を利用するときはxxxx.hのみを、
・インライン関数を利用するときはさらにxxxx_proto.hとxxxx_func.hをこの順番を守ってインクルード

MassiveThreads : やりたいことがはっきりわかる.他に何かいい手は?
